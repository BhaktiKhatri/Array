package Array;

import java.util.ArrayList;
import java.util.Arrays;

/*
 * 792. Number of Matching Subsequences
 * A String is a subsequence of a given String, that is generated by deleting some character of a given string without changing its order.
 * https://leetcode.com/problems/number-of-matching-subsequences/description/
 * Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S
 * Example: Input: S = "abcde", words = ["a", "bb", "acd", "ace"]; Output: 3
 * Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace"
 * Note: All words in words and S will only consists of lowercase letters. The length of S will be in the range of [1, 50000].
 * The length of words will be in the range of [1, 5000]. The length of words[i] will be in the range of [1, 50].
 * Explanation and Code from: https://leetcode.com/problems/number-of-matching-subsequences/solution/
 * Time Complexity: O(S.length + ∑i words[i].length)
 * Space Complexity: O(words.length). (In Java, our additional space complexity is O(∑​i​​ words[i].length), 
 * but can be made to be O(words.length) with a pointer based implementation.)
 * Google
 * Medium
 */

class Node {
    String word;
    int index;
    
    public Node(String w, int i) {
    	System.out.println("w: "+w+" i: "+i);
    	
        word = w;
        index = i;
    }
}

public class NumberOfMatchingSubsequences {

	public static int numMatchingSubseq(String S, String[] words) {
        int ans = 0;
        ArrayList<Node>[] heads = new ArrayList[26];
        
        System.out.println("S: "+S+" words: "+Arrays.toString(words));
        
        for(int i=0; i<26; i++) {
            heads[i] = new ArrayList<Node>();
        }
        
        for(String word: words) {
        	System.out.println("word: "+word+" word.charAt(0): "+word.charAt(0)+" word.charAt(0) - 'a': "+(word.charAt(0) - 'a')+" heads[word.charAt(0) - 'a']: "+heads[word.charAt(0) - 'a']);
            heads[word.charAt(0) - 'a'].add(new Node(word, 0));
        }
        
        for(char ch: S.toCharArray()) {
        	
        	System.out.println("ch: "+ch+" heads[ch - 'a']: "+heads[ch - 'a']);
        	
            ArrayList<Node> old_bucket = heads[ch - 'a'];
            heads[ch - 'a'] = new ArrayList<Node>();

            System.out.println("old_bucket: "+old_bucket);
            
            for(Node node: old_bucket) {
            	System.out.println("node: "+node+" node.index: "+node.index+" node.word: "+node.word);
            	
                node.index++;
                
                System.out.println("node.index: "+node.index+" node.word.length(): "+node.word.length()+" ans: "+ans);
               
                if(node.index == node.word.length()) {
                    ans++;
                } 
                else {
                	System.out.println("node.word.charAt(node.index) - 'a': "+(node.word.charAt(node.index) - 'a')+" heads[node.word.charAt(node.index) - 'a']: "+heads[node.word.charAt(node.index) - 'a']);
                    heads[node.word.charAt(node.index) - 'a'].add(node);
                }
            }
            
            System.out.println("old_bucket: "+old_bucket);
            
            old_bucket.clear();
        }
        System.out.println("ans: "+ans);
        
        return ans;
    }
	
	public static void main(String[] args) {
		String S = "abcde";
		String[] words = {"a", "bb", "acd", "ace"};
		
		System.out.println(numMatchingSubseq(S, words));
	}

}
